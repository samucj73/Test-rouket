# RoletaHybridIA.py - SISTEMA ESPECIALISTA 450+ COM ESTRAT√âGIA DE ALTA ASSERTIVIDADE
import streamlit as st
import json
import os
import time
import requests
from collections import deque, Counter
from streamlit_autorefresh import st_autorefresh
import logging
import numpy as np
import pandas as pd
import io
from datetime import datetime, timedelta
import warnings
warnings.filterwarnings('ignore')

# =============================
# Configura√ß√µes
# =============================
HISTORICO_PATH = "historico_hybrid_ia.json"
METRICAS_PATH = "metricas_hybrid_ia.json"
API_URL = "https://api.casinoscores.com/svc-evolution-game-events/api/xxxtremelightningroulette/latest"
HEADERS = {"User-Agent": "Mozilla/5.0"}

# TELEGRAM - CANAL PRINCIPAL
TELEGRAM_TOKEN = "7900056631:AAHjG6iCDqQdGTfJI6ce0AZ0E2ilV2fV9RY"
TELEGRAM_CHAT_ID = "5121457416"

# TELEGRAM - CANAL ALTERNATIVO (ALERTAS ESTRAT√âGICOS)
TELEGRAM_TOKEN_ALTERNATIVO = "7900056631:AAHjG6iCDqQdGTfJI6ce0AZ0E2ilV2fV9RY"
TELEGRAM_CHAT_ID_ALTERNATIVO = "-1002940111195"

# DISPOSI√á√ÉO F√çSICA REAL DA ROLETA
ROULETTE_PHYSICAL_LAYOUT = [
    [1, 4, 7, 10, 13, 16, 19, 22, 25, 28, 31, 34],
    [2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35],
    [3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36]
]

PRIMEIRA_DUZIA = list(range(1, 13))
SEGUNDA_DUZIA = list(range(13, 25))
TERCEIRA_DUZIA = list(range(25, 37))

COLUNA_1 = [1, 4, 7, 10, 13, 16, 19, 22, 25, 28, 31, 34]
COLUNA_2 = [2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35]  
COLUNA_3 = [3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36]

# =============================
# CONFIGURA√á√ÉO ESPECIALISTA - ESTRAT√âGIA DE ALTA ASSERTIVIDADE
# =============================
MIN_HISTORICO_TREINAMENTO = 150  # Reduzido para ativar mais cedo
NUMERO_PREVISOES = 8  # REDUZIDO DRAMATICAMENTE PARA MAIOR ASSERTIVIDADE

# Fases do sistema
FASE_INICIAL = 30
FASE_INTERMEDIARIA = 80  
FASE_AVANCADA = 120
FASE_ESPECIALISTA = 150

# Configurar logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# =============================
# UTILIT√ÅRIOS ROBUSTOS
# =============================
def enviar_telegram(msg: str, token=TELEGRAM_TOKEN, chat_id=TELEGRAM_CHAT_ID):
    try:
        url = f"https://api.telegram.org/bot{token}/sendMessage"
        payload = {
            "chat_id": chat_id, 
            "text": msg,
            "parse_mode": "Markdown"
        }
        requests.post(url, data=payload, timeout=10)
        logging.info(f"üì§ Telegram enviado: {msg}")
    except Exception as e:
        logging.error(f"Erro ao enviar para Telegram: {e}")

def carregar_historico():
    try:
        if os.path.exists(HISTORICO_PATH):
            with open(HISTORICO_PATH, "r") as f:
                historico = json.load(f)
            historico_valido = [h for h in historico if isinstance(h, dict) and 'number' in h and h['number'] is not None]
            logging.info(f"üìÅ Hist√≥rico carregado: {len(historico_valido)} registros v√°lidos")
            return historico_valido
        return []
    except Exception as e:
        logging.error(f"Erro ao carregar hist√≥rico: {e}")
        return []

def salvar_historico(numero_dict):
    try:
        if not isinstance(numero_dict, dict) or numero_dict.get('number') is None:
            logging.error("‚ùå Tentativa de salvar n√∫mero inv√°lido")
            return False
            
        historico_existente = carregar_historico()
        timestamp_novo = numero_dict.get("timestamp")
        
        ja_existe = any(
            registro.get("timestamp") == timestamp_novo 
            for registro in historico_existente 
            if isinstance(registro, dict)
        )
        
        if not ja_existe:
            historico_existente.append(numero_dict)
            with open(HISTORICO_PATH, "w") as f:
                json.dump(historico_existente, f, indent=2)
            logging.info(f"‚úÖ N√∫mero {numero_dict['number']} salvo no hist√≥rico")
            return True
        return False
    except Exception as e:
        logging.error(f"Erro ao salvar hist√≥rico: {e}")
        return False

def fetch_latest_result():
    try:
        response = requests.get(API_URL, headers=HEADERS, timeout=10)
        response.raise_for_status()
        data = response.json()
        
        game_data = data.get("data", {})
        if not game_data:
            logging.error("‚ùå Estrutura da API inv√°lida: data n√£o encontrado")
            return None
            
        result = game_data.get("result", {})
        if not result:
            logging.error("‚ùå Estrutura da API inv√°lida: result n√£o encontrado")
            return None
            
        outcome = result.get("outcome", {})
        if not outcome:
            logging.error("‚ùå Estrutura da API inv√°lida: outcome n√£o encontrado")
            return None
            
        number = outcome.get("number")
        if number is None:
            logging.error("‚ùå N√∫mero n√£o encontrado na resposta da API")
            return None
            
        timestamp = game_data.get("startedAt")
        
        return {"number": number, "timestamp": timestamp}
        
    except requests.exceptions.RequestException as e:
        logging.error(f"‚ùå Erro de rede ao buscar resultado: {e}")
        return None
    except Exception as e:
        logging.error(f"‚ùå Erro inesperado ao buscar resultado: {e}")
        return None

def obter_vizinhos_fisicos(numero):
    """Retorna vizinhos f√≠sicos na mesa"""
    if numero == 0:
        return [32, 15, 19, 4, 21, 2, 25]
    
    vizinhos = set()
    
    for col_idx, coluna in enumerate(ROULETTE_PHYSICAL_LAYOUT):
        if numero in coluna:
            num_idx = coluna.index(numero)
            
            if num_idx > 0:
                vizinhos.add(coluna[num_idx - 1])
            if num_idx < len(coluna) - 1:
                vizinhos.add(coluna[num_idx + 1])
                
            if col_idx > 0:
                if num_idx < len(ROULETTE_PHYSICAL_LAYOUT[col_idx - 1]):
                    vizinhos.add(ROULETTE_PHYSICAL_LAYOUT[col_idx - 1][num_idx])
            if col_idx < 2:
                if num_idx < len(ROULETTE_PHYSICAL_LAYOUT[col_idx + 1]):
                    vizinhos.add(ROULETTE_PHYSICAL_LAYOUT[col_idx + 1][num_idx])
    
    return list(vizinhos)

def validar_previsao(previsao):
    if not previsao or not isinstance(previsao, list):
        return []
    
    previsao_limpa = [
        num for num in previsao 
        if num is not None 
        and isinstance(num, (int, float))
        and 0 <= num <= 36
    ]
    
    return previsao_limpa

# =============================
# ESTRAT√âGIA DE ALTA ASSERTIVIDADE
# =============================
def analisar_padroes_assertivos(historico):
    """An√°lise AGGRESSIVA focada em padr√µes de alta probabilidade"""
    
    numeros = [h['number'] for h in historico if h.get('number') is not None]
    
    if len(numeros) < 10:
        return {"numeros_quentes": [2, 5, 8, 11, 14, 17, 23, 29], "padrao_atual": "inicial"}
    
    # AN√ÅLISE DE PADR√ïES DE REPETI√á√ÉO IMEDIATA
    padroes_repeticao = []
    for i in range(1, len(numeros)):
        if numeros[i] == numeros[i-1]:
            padroes_repeticao.append(numeros[i])
    
    # AN√ÅLISE DE SEQU√äNCIAS DE VIZINHAN√áA
    sequencias_vizinhanca = []
    for i in range(1, min(6, len(numeros))):
        vizinhos_anteriores = obter_vizinhos_fisicos(numeros[-i])
        if numeros[-1] in vizinhos_anteriores:
            sequencias_vizinhanca.extend(vizinhos_anteriores)
    
    # N√öMEROS QUENTES (√∫ltimas 15 rodadas)
    ultimos_15 = numeros[-15:] if len(numeros) >= 15 else numeros
    contagem_recente = Counter(ultimos_15)
    numeros_quentes = [num for num, count in contagem_recente.most_common(5) if count >= 2]
    
    # N√öMEROS COM ATRASO (n√£o saem h√° mais de 8 rodadas)
    numeros_atrasados = []
    for num in range(0, 37):
        if num in numeros:
            ultima_ocorrencia = len(numeros) - 1 - numeros[::-1].index(num)
            atraso = len(numeros) - ultima_ocorrencia
            if atraso > 8:
                numeros_atrasados.append(num)
    
    # PADR√ÉO DE ALTERN√ÇNCIA DE CORES (se aplic√°vel)
    cores_alternadas = []
    ultima_cor = "preto" if numeros[-1] in [2,4,6,8,10,11,13,15,17,20,22,24,26,28,29,31,33,35] else "vermelho" if numeros[-1] in [1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36] else "zero"
    
    return {
        "numeros_quentes": numeros_quentes[:3],
        "padroes_repeticao": list(set(padroes_repeticao))[:2],
        "sequencias_vizinhanca": list(set(sequencias_vizinhanca))[:3],
        "numeros_atrasados": numeros_atrasados[:3],
        "ultima_cor": ultima_cor,
        "total_analisado": len(numeros)
    }

def identificar_nucleo_assertivo(historico):
    """Identifica o n√∫cleo de n√∫meros com maior probabilidade REAL"""
    
    numeros = [h['number'] for h in historico if h.get('number') is not None]
    
    if len(numeros) < 5:
        return [2, 5, 8, 11, 14, 17, 23, 29]
    
    analise = analisar_padroes_assertivos(historico)
    
    nucleo = set()
    
    # 1. ADICIONAR N√öMEROS QUENTES (alta prioridade)
    nucleo.update(analise["numeros_quentes"])
    
    # 2. ADICIONAR PADR√ïES DE REPETI√á√ÉO (muito forte)
    nucleo.update(analise["padroes_repeticao"])
    
    # 3. ADICIONAR SEQU√äNCIAS DE VIZINHAN√áA
    nucleo.update(analise["sequencias_vizinhanca"])
    
    # 4. ADICIONAR 1-2 N√öMEROS ATRASADOS (para diversifica√ß√£o)
    if analise["numeros_atrasados"]:
        nucleo.add(analise["numeros_atrasados"][0])
    
    # 5. GARANTIR ZERO SE ESTIVER QUENTE
    if numeros.count(0) >= max(1, len(numeros) * 0.05):
        nucleo.add(0)
    
    # 6. COMPLETAR COM N√öMEROS ESTRAT√âGICOS DA COLUNA DO MEIO
    if len(nucleo) < NUMERO_PREVISOES:
        complemento = [2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35]
        for num in complemento:
            if len(nucleo) < NUMERO_PREVISOES and num not in nucleo:
                nucleo.add(num)
    
    return list(nucleo)[:NUMERO_PREVISOES]

def gerar_entrada_ultra_assertiva(previsao_completa, historico):
    """Estrat√©gia ULTRA ASSERTIVA - M√°ximo 8 n√∫meros com alta confian√ßa"""
    
    if not historico:
        return [2, 5, 8, 11, 14, 17, 23, 29]
    
    # USAR APENAS O N√öCLEO ASSERTIVO
    nucleo_assertivo = identificar_nucleo_assertivo(historico)
    
    # APLICAR FILTRO DE CONFIRMA√á√ÉO R√ÅPIDA
    entrada_filtrada = filtrar_por_confirmacao_rapida(historico, nucleo_assertivo)
    
    return entrada_filtrada[:NUMERO_PREVISOES]

def filtrar_por_confirmacao_rapida(historico, numeros_candidatos):
    """Filtro R√ÅPIDO baseado em confirma√ß√µes imediatas"""
    
    if len(numeros_candidatos) <= NUMERO_PREVISOES:
        return numeros_candidatos
    
    numeros = [h['number'] for h in historico if h.get('number') is not None]
    
    scores = {}
    
    for numero in numeros_candidatos:
        score = 0
        
        # CONFIRMA√á√ÉO 1: √â UM DOS √öLTIMOS 3 N√öMEROS?
        if numero in numeros[-3:]:
            score += 3
        
        # CONFIRMA√á√ÉO 2: √â VIZINHO DOS √öLTIMOS 2 N√öMEROS?
        for recente in numeros[-2:]:
            if numero in obter_vizinhos_fisicos(recente):
                score += 2
                break
        
        # CONFIRMA√á√ÉO 3: TEVE REPETI√á√ÉO RECENTE (√∫ltimas 10 rodadas)
        if numeros[-10:].count(numero) >= 2:
            score += 2
        
        # CONFIRMA√á√ÉO 4: EST√Å NA MESMA COLUNA DOS √öLTIMOS N√öMEROS?
        ultima_coluna = None
        for num in numeros[-2:]:
            if num in COLUNA_1: ultima_coluna = 1
            elif num in COLUNA_2: ultima_coluna = 2
            elif num in COLUNA_3: ultima_coluna = 3
        
        if ultima_coluna:
            if (ultima_coluna == 1 and numero in COLUNA_1) or \
               (ultima_coluna == 2 and numero in COLUNA_2) or \
               (ultima_coluna == 3 and numero in COLUNA_3):
                score += 1
        
        scores[numero] = score
    
    # SELECIONAR OS COM MAIOR SCORE
    melhores = sorted(scores.items(), key=lambda x: x[1], reverse=True)
    return [num for num, score in melhores if score >= 2][:NUMERO_PREVISOES]

def enviar_alerta_assertivo(entrada_estrategica, ultimo_numero, historico, performance):
    """Envia alerta ULTRA ASSERTIVO para Telegram"""
    
    try:
        if not entrada_estrategica:
            return
        
        # MENSAGEM DIRETA E PODEROSA
        mensagem = "üéØ **ENTRADA ASSERTIVA** üéØ\n\n"
        
        # Ordenar n√∫meros
        numeros_ordenados = sorted(entrada_estrategica)
        
        # Formato compacto e impactante
        mensagem += "üî• " + " ‚Ä¢ ".join(map(str, numeros_ordenados)) + " üî•"
        
        # Estat√≠sticas de performance
        mensagem += f"\n\nüìä Assertividade: {performance['taxa_acerto']}"
        mensagem += f"\n‚úÖ Acertos: {performance['acertos']} | ‚ùå Erros: {performance['erros']}"
        
        # ENVIAR PARA TELEGRAM
        enviar_telegram(mensagem, TELEGRAM_TOKEN_ALTERNATIVO, TELEGRAM_CHAT_ID_ALTERNATIVO)
        
        # Salvar entrada atual
        st.session_state.ultima_entrada_estrategica = entrada_estrategica
        
        logging.info(f"üì§ Alerta ASSERTIVO enviado: {len(entrada_estrategica)} n√∫meros")
        
    except Exception as e:
        logging.error(f"Erro ao enviar alerta assertivo: {e}")

def verificar_resultado_entrada_anterior(numero_sorteado):
    """Verifica√ß√£o R√ÅPIDA de resultado"""
    
    entrada_anterior = st.session_state.get('ultima_entrada_estrategica', [])
    
    if not entrada_anterior or numero_sorteado is None:
        return None
    
    if numero_sorteado in entrada_anterior:
        mensagem_green = f"‚úÖ **GREEN!** Acertamos {numero_sorteado}!"
        enviar_telegram(mensagem_green, TELEGRAM_TOKEN_ALTERNATIVO, TELEGRAM_CHAT_ID_ALTERNATIVO)
        return "GREEN"
    else:
        mensagem_red = f"‚ùå **RED** {numero_sorteado} n√£o estava"
        enviar_telegram(mensagem_red, TELEGRAM_TOKEN_ALTERNATIVO, TELEGRAM_CHAT_ID_ALTERNATIVO)
        return "RED"

# =============================
# SISTEMA ESPECIALISTA DE ALTA ASSERTIVIDADE
# =============================
class IA_Assertiva:
    def __init__(self):
        self.historico_analises = deque(maxlen=50)
        
    def prever_com_alta_assertividade(self, historico):
        """Sistema PRINCIPAL de previs√£o assertiva"""
        
        historico_size = len(historico)
        
        if historico_size >= FASE_ESPECIALISTA:
            logging.info(f"üöÄ MODO ASSERTIVO ATIVO - {historico_size} registros")
            return self.modo_assertivo_avancado(historico)
        elif historico_size >= FASE_AVANCADA:
            return self.modo_assertivo_intermediario(historico)
        else:
            return self.modo_assertivo_basico(historico)
    
    def modo_assertivo_avancado(self, historico):
        """Modo AVAN√áADO com an√°lise complexa"""
        numeros = [h['number'] for h in historico if h.get('number') is not None]
        
        # AN√ÅLISE DE PADR√ïES COMPLEXOS
        analise = analisar_padroes_assertivos(historico)
        
        # COMBINA√á√ÉO ESTRAT√âGICA
        previsao_final = set()
        
        # 1. N√öCLEO PRINCIPAL
        previsao_final.update(analise["numeros_quentes"])
        previsao_final.update(analise["padroes_repeticao"])
        
        # 2. AN√ÅLISE DE TEND√äNCIAS
        tendencias = self.analisar_tendencias_avancadas(numeros)
        previsao_final.update(tendencias[:3])
        
        # 3. PADR√ïES TEMPORAIS
        padroes_temporais = self.detectar_padroes_temporais(historico)
        previsao_final.update(padroes_temporais[:2])
        
        # GARANTIR TAMANHO M√ÅXIMO
        return self.otimizar_previsao_assertiva(list(previsao_final), historico)
    
    def modo_assertivo_intermediario(self, historico):
        """Modo INTERMEDI√ÅRIO otimizado"""
        return identificar_nucleo_assertivo(historico)
    
    def modo_assertivo_basico(self, historico):
        """Modo B√ÅSICO para hist√≥rico pequeno"""
        numeros = [h['number'] for h in historico if h.get('number') is not None]
        
        if len(numeros) < 5:
            return [2, 5, 8, 11, 14, 17, 23, 29]
        
        # ESTRAT√âGIA SIMPLES MAS EFETIVA
        previsao = set()
        
        # √öltimos n√∫meros
        previsao.update(numeros[-3:])
        
        # Vizinhos dos √∫ltimos
        for num in numeros[-2:]:
            previsao.update(obter_vizinhos_fisicos(num)[:2])
        
        # Completar com estrat√©gicos
        estrategicos = [2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35]
        for num in estrategicos:
            if len(previsao) < NUMERO_PREVISOES:
                previsao.add(num)
        
        return list(previsao)[:NUMERO_PREVISOES]
    
    def analisar_tendencias_avancadas(self, numeros):
        """An√°lise de tend√™ncias complexas"""
        if len(numeros) < 10:
            return []
        
        tendencias = []
        
        # Tend√™ncia de repeti√ß√£o em ciclos curtos
        for i in range(len(numeros) - 4):
            if numeros[i] == numeros[i+2]:
                tendencias.append(numeros[i])
        
        # Tend√™ncia de altern√¢ncia
        for i in range(len(numeros) - 3):
            if (numeros[i] in PRIMEIRA_DUZIA and numeros[i+1] in TERCEIRA_DUZIA and 
                numeros[i+2] in PRIMEIRA_DUZIA):
                tendencias.extend([n for n in PRIMEIRA_DUZIA if n not in tendencias][:2])
        
        return list(set(tendencias))[:5]
    
    def detectar_padroes_temporais(self, historico):
        """Detecta padr√µes baseados em tempo"""
        try:
            padroes = []
            
            # Agrupar por minutos (padr√µes de hor√°rio)
            for registro in historico[-20:]:
                if 'timestamp' in registro:
                    try:
                        hora = datetime.fromisoformat(registro['timestamp'].replace('Z', '+00:00')).minute
                        # Padr√£o: n√∫meros que saem em minutos espec√≠ficos
                        if hora % 5 == 0:  # Minutos m√∫ltiplos de 5
                            padroes.append(registro['number'])
                    except:
                        continue
            
            return list(set(padroes))[:3]
        except:
            return []
    
    def otimizar_previsao_assertiva(self, previsao, historico):
        """Otimiza√ß√£o FINAL da previs√£o"""
        if len(previsao) <= NUMERO_PREVISOES:
            return previsao
        
        # FILTRAR PELA ESTRAT√âGIA DE CONFIRMA√á√ÉO
        return filtrar_por_confirmacao_rapida(historico, previsao)

# =============================
# GESTOR PRINCIPAL ASSERTIVO
# =============================
class GestorAssertivo:
    def __init__(self):
        self.ia_assertiva = IA_Assertiva()
        self.historico = deque(carregar_historico(), maxlen=500)
        
    def adicionar_numero(self, numero_dict):
        if isinstance(numero_dict, dict) and numero_dict.get('number') is not None:
            self.historico.append(numero_dict)
        
    def gerar_previsao_assertiva(self):
        try:
            previsao = self.ia_assertiva.prever_com_alta_assertividade(self.historico)
            previsao_validada = validar_previsao(previsao)
            
            # GARANTIR SEMPRE 8 N√öMEROS
            if len(previsao_validada) < NUMERO_PREVISOES:
                logging.warning(f"‚ö†Ô∏è Previs√£o com {len(previsao_validada)} n√∫meros. Completando...")
                previsao_validada = self.completar_para_8(previsao_validada)
            
            logging.info(f"‚úÖ Previs√£o ASSERTIVA gerada: {len(previsao_validada)} n√∫meros")
            return previsao_validada
            
        except Exception as e:
            logging.error(f"Erro ao gerar previs√£o: {e}")
            return [2, 5, 8, 11, 14, 17, 23, 29]
    
    def completar_para_8(self, previsao):
        """Completa sempre para 8 n√∫meros"""
        if len(previsao) >= NUMERO_PREVISOES:
            return previsao[:NUMERO_PREVISOES]
        
        numeros_completos = set(previsao)
        
        # N√öMEROS ESTRAT√âGICOS DA COLUNA DO MEIO
        estrategicos = [2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35]
        
        for num in estrategicos:
            if len(numeros_completos) < NUMERO_PREVISOES:
                numeros_completos.add(num)
        
        return list(numeros_completos)[:NUMERO_PREVISOES]
    
    def get_status_sistema(self):
        try:
            historico_size = len(self.historico)
            
            if historico_size < FASE_INICIAL:
                return "üü° Iniciando", "Estrat√©gia B√°sica"
            elif historico_size < FASE_INTERMEDIARIA:
                return "üü† Desenvolvendo", "An√°lise Intermedi√°ria"
            elif historico_size < FASE_AVANCADA:
                return "üü¢ IA Ativa", "Padr√µes Detectados"
            else:
                return "üéØ ASSERTIVO", "Alta Probabilidade"
                
        except:
            return "‚ö™ Sistema", "Carregando..."
    
    def get_analise_detalhada(self):
        """An√°lise simplificada mas efetiva"""
        if not self.historico:
            return {
                "modo_assertivo": False,
                "historico_total": 0,
                "confianca": "Baixa",
                "estrategia_ativa": "Inicial"
            }
        
        historico_size = len(self.historico)
        modo_assertivo = historico_size >= FASE_AVANCADA
        
        analise = analisar_padroes_assertivos(self.historico)
        
        return {
            "modo_assertivo": modo_assertivo,
            "historico_total": historico_size,
            "confianca": "Alta" if historico_size > 100 else "M√©dia" if historico_size > 50 else "Baixa",
            "estrategia_ativa": "N√∫cleo Assertivo",
            "numeros_quentes": analise.get("numeros_quentes", []),
            "padrao_detectado": len(analise.get("padroes_repeticao", [])) > 0
        }

# =============================
# STREAMLIT APP ASSERTIVO
# =============================
st.set_page_config(
    page_title="Roleta - IA Assertiva", 
    page_icon="üéØ", 
    layout="centered"
)

st.title("üéØ SISTEMA ASSERTIVO - ALTA PROBABILIDADE")
st.markdown("### **Estrat√©gia com 8 N√∫meros para M√°xima Assertividade**")

st_autorefresh(interval=3000, key="refresh")

# Inicializa√ß√£o session_state
defaults = {
    "gestor": GestorAssertivo(),
    "previsao_atual": [],
    "acertos": 0,
    "erros": 0,
    "contador_rodadas": 0,
    "ultimo_timestamp": None,
    "ultimo_numero": None,
    "status_ia": "üü° Inicializando",
    "estrategia_atual": "Aguardando dados",
    "ultima_entrada_estrategica": [],
    "resultado_entrada_anterior": None
}

for k, v in defaults.items():
    if k not in st.session_state:
        st.session_state[k] = v

st.session_state.previsao_atual = validar_previsao(st.session_state.previsao_atual)

# =============================
# PROCESSAMENTO PRINCIPAL ASSERTIVO
# =============================
try:
    resultado = fetch_latest_result()

    novo_sorteio = False
    if resultado and resultado.get("timestamp"):
        if (st.session_state.ultimo_timestamp is None or 
            resultado.get("timestamp") != st.session_state.ultimo_timestamp):
            novo_sorteio = True

    if resultado and novo_sorteio:
        numero_dict = {"number": resultado["number"], "timestamp": resultado["timestamp"]}
        
        salvo_com_sucesso = salvar_historico(numero_dict)
        if salvo_com_sucesso:
            st.session_state.gestor.adicionar_numero(numero_dict)
        
        st.session_state.ultimo_timestamp = resultado["timestamp"]
        numero_real = resultado["number"]
        st.session_state.ultimo_numero = numero_real

        # ATUALIZAR STATUS
        st.session_state.status_ia, st.session_state.estrategia_atual = st.session_state.gestor.get_status_sistema()

        # VERIFICAR ENTRADA ANTERIOR
        st.session_state.resultado_entrada_anterior = verificar_resultado_entrada_anterior(numero_real)

        # CONFERIR PREVIS√ÉO ANTERIOR
        previsao_valida = validar_previsao(st.session_state.previsao_atual)
        if previsao_valida:
            acertou = numero_real in previsao_valida
            if acertou:
                st.session_state.acertos += 1
                st.success(f"üéØ **ACERTOU!** N√∫mero {numero_real} estava na previs√£o!")
            else:
                st.session_state.erros += 1
                st.error(f"üî¥ N√∫mero {numero_real} n√£o estava")

        # GERAR NOVA PREVIS√ÉO ASSERTIVA
        nova_previsao = st.session_state.gestor.gerar_previsao_assertiva()
        st.session_state.previsao_atual = validar_previsao(nova_previsao)
        
        # GERAR ENTRADA ULTRA ASSERTIVA
        entrada_assertiva = gerar_entrada_ultra_assertiva(
            st.session_state.previsao_atual, 
            list(st.session_state.gestor.historico)
        )
        
        # Calcular performance
        total = st.session_state.acertos + st.session_state.erros
        taxa_acerto = (st.session_state.acertos / total * 100) if total > 0 else 0
        performance = {
            'acertos': st.session_state.acertos,
            'erros': st.session_state.erros,
            'taxa_acerto': f"{taxa_acerto:.1f}%"
        }
        
        # ENVIAR ALERTA ASSERTIVO
        enviar_alerta_assertivo(
            entrada_assertiva, 
            numero_real, 
            list(st.session_state.gestor.historico),
            performance
        )

        st.session_state.contador_rodadas += 1

except Exception as e:
    logging.error(f"Erro no processamento: {e}")
    st.error("üî¥ Reiniciando sistema...")
    st.session_state.previsao_atual = [2, 5, 8, 11, 14, 17, 23, 29]

# =============================
# INTERFACE STREAMLIT ASSERTIVA
# =============================
st.markdown("---")

# STATUS DO SISTEMA
col1, col2, col3, col4 = st.columns(4)
with col1:
    st.metric("üß† Status", st.session_state.status_ia)
with col2:
    st.metric("üìä Hist√≥rico", f"{len(st.session_state.gestor.historico)}")
with col3:
    ultimo_numero = st.session_state.ultimo_numero
    display_numero = ultimo_numero if ultimo_numero is not None else "-"
    st.metric("üé≤ √öltimo", display_numero)
with col4:
    st.metric("üéØ Estrat√©gia", st.session_state.estrategia_atual)

# RESULTADO ENTRADA ANTERIOR
if st.session_state.resultado_entrada_anterior:
    if st.session_state.resultado_entrada_anterior == "GREEN":
        st.success(f"‚úÖ **ENTRADA ANTERIOR: GREEN!** Acertamos {st.session_state.ultimo_numero}!")
    else:
        st.error(f"‚ùå **ENTRADA ANTERIOR: RED** {st.session_state.ultimo_numero} n√£o estava")

# AN√ÅLISE DO SISTEMA
st.subheader("üîç An√°lise Assertiva")
analise = st.session_state.gestor.get_analise_detalhada()

col1, col2, col3 = st.columns(3)
with col1:
    st.metric("üöÄ Modo", "ASSERTIVO" if analise["modo_assertivo"] else "EVOLUINDO")
with col2:
    st.metric("üí™ Confian√ßa", analise["confianca"])
with col3:
    st.metric("üìà Padr√£o", "‚úÖ" if analise["padrao_detectado"] else "‚è≥")

# PREVIS√ÉO ATUAL
st.markdown("---")
st.subheader("üéØ PREVIS√ÉO ASSERTIVA ATUAL")

previsao_valida = validar_previsao(st.session_state.previsao_atual)

if previsao_valida:
    st.success(f"**üî• {len(previsao_valida)} N√öMEROS SELECIONADOS **")
    
    # Display IMPACTANTE
    st.markdown(f"### **{'  ‚Ä¢  '.join(map(str, sorted(previsao_valida)))}**")
    
    st.write(f"**Estrat√©gia:** {analise['estrategia_ativa']}")
    
    if analise['numeros_quentes']:
        st.write(f"**N√∫meros Quentes:** {', '.join(map(str, analise['numeros_quentes']))}")
    
else:
    st.warning("‚ö†Ô∏è Inicializando sistema assertivo...")
    st.session_state.previsao_atual = [2, 5, 8, 11, 14, 17, 23, 29]

# ENTRADA ASSERTIVA
st.markdown("---")
st.subheader("üéØ ENTRADA PARA TELEGRAM")

entrada_assertiva = gerar_entrada_ultra_assertiva(
    st.session_state.previsao_atual, 
    list(st.session_state.gestor.historico)
)

if entrada_assertiva:
    st.success(f"**üîî {len(entrada_assertiva)} N√öMEROS CONFIRMADOS**")
    
    # Mostrar mensagem do Telegram
    numeros_ordenados = sorted(entrada_assertiva)
    mensagem_telegram = f"üéØ ENTRADA ASSERTIVA üéØ\n\nüî• {' ‚Ä¢ '.join(map(str, numeros_ordenados))} üî•"
    
    st.code(mensagem_telegram, language=None)
    
    # Bot√£o de envio
    if st.button("üì§ Enviar Alerta Assertivo"):
        performance = {
            'acertos': st.session_state.acertos,
            'erros': st.session_state.erros,
            'taxa_acerto': f"{(st.session_state.acertos/(st.session_state.acertos+st.session_state.erros)*100):.1f}%" if (st.session_state.acertos+st.session_state.erros) > 0 else "0%"
        }
        
        enviar_alerta_assertivo(
            entrada_assertiva, 
            st.session_state.ultimo_numero, 
            list(st.session_state.gestor.historico),
            performance
        )
        st.success("‚úÖ Alerta ASSERTIVO enviado!")
else:
    st.warning("‚è≥ Gerando entrada assertiva...")

# PERFORMANCE
st.markdown("---")
st.subheader("üìä Performance do Sistema")

col1, col2, col3 = st.columns(3)
with col1:
    st.metric("‚úÖ Acertos", st.session_state.acertos)
with col2:
    st.metric("‚ùå Erros", st.session_state.erros)
with col3:
    total = st.session_state.acertos + st.session_state.erros
    taxa_acerto = (st.session_state.acertos / total * 100) if total > 0 else 0
    st.metric("üìà Assertividade", f"{taxa_acerto:.1f}%")

# CONTROLES
st.markdown("---")
st.subheader("‚öôÔ∏è Controles")

col1, col2 = st.columns(2)
with col1:
    if st.button("üîÑ Nova Previs√£o"):
        nova_previsao = st.session_state.gestor.gerar_previsao_assertiva()
        st.session_state.previsao_atual = validar_previsao(nova_previsao)
        st.rerun()

with col2:
    if st.button("üóëÔ∏è Reiniciar"):
        if os.path.exists(HISTORICO_PATH):
            os.remove(HISTORICO_PATH)
        st.session_state.gestor.historico.clear()
        st.session_state.acertos = 0
        st.session_state.erros = 0
        st.session_state.ultima_entrada_estrategica = []
        st.rerun()

st.markdown("---")
st.markdown("### üöÄ **SISTEMA ASSERTIVO ATIVADO**")
st.markdown("*Estrat√©gia de 8 n√∫meros para m√°xima probabilidade de acerto*")

# Rodap√©
st.markdown("---")
st.markdown("**üéØ Sistema Assertivo v9.0** - *Alta Assertividade com 8 N√∫meros*")
