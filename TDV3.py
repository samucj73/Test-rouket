import streamlit as st
import requests
import joblib
from collections import Counter, deque, defaultdict
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import time
import csv
import os
import math

# ==========================
# ======== v4.0 ===========
# ==========================

# === CONFIGURA√á√ïES FIXAS ===
TELEGRAM_TOKEN = "7900056631:AAHjG6iCDqQdGTfJI6ce0AZ0E2ilV2fV9RY"
CHAT_ID = "-1002979544095"
API_URL = "https://api.casinoscores.com/svc-evolution-game-events/api/xxxtremelightningroulette/latest"
HISTORICO_PATH = "historico_v35.pkl"  # mant√©m seu arquivo de hist√≥rico
CSV_LOG_PATH = "historico_feedback_v35.csv"

# === CONFIGURA√á√ïES ADMIN (barra lateral) ===
st.set_page_config(layout="wide", page_title="IA Elite Master - Roleta v4.0 (Combinat√≥ria)")
st.sidebar.title("‚öôÔ∏è Painel Admin - Combinat√≥ria (Elite Master)")

# Par√¢metros do m√©todo combinat√≥rio
DECAY_HALFLIFE = st.sidebar.slider("Halflife (em giros) ‚Äî peso de decaimento", 80, 5_000, 400, step=10)
CANDIDATE_POOL = st.sidebar.slider("Tamanho do pool candidato (top N)", 9, 30, 20)
PENALTY_PROXIMITY = st.sidebar.slider("Penalidade por proximidade f√≠sica (0-1)", 0.0, 1.0, 0.35, step=0.05)
USE_RECENT_ONLY = st.sidebar.checkbox("Usar todo o hist√≥rico salvo (desmarque para somente janela)", value=True)
RECENT_WINDOW = st.sidebar.number_input("Janela recente (se n√£o usar todo hist√≥rico)", 50, 10000, 500, step=50)

st.sidebar.markdown("---")
st.sidebar.info("Estrat√©gia: an√°lise combinat√≥ria ‚Äî combina 9 n√∫meros distintos por rodada")

# ==========================
# === INICIALIZA√á√ÉO UI ====
# ==========================
st.title("üéØ Estrat√©gia Combinat√≥ria - Roleta (v4.0)")

# Hist√≥rico
HIST_MAXLEN = 100000
if os.path.exists(HISTORICO_PATH):
    historico_salvo = joblib.load(HISTORICO_PATH)
    st.session_state.historico = deque(historico_salvo, maxlen=HIST_MAXLEN)
else:
    st.session_state.historico = deque(maxlen=HIST_MAXLEN)

# Estado padr√£o
defaults = {
    "ultimo_timestamp": None,
    "entrada_atual": None,   # ser√° dict com 'entrada' (list) e 'index_feedback'
    "alertas_enviados": set(),
    "feedbacks_processados": set(),
    "greens": 0,
    "reds": 0,
    "historico_scores": deque(maxlen=500),
    "alert_probs": [],
    "nova_entrada": False,
    "tempo_alerta": 0,
    "total_alertas": 0,
}
for k, v in defaults.items():
    if k not in st.session_state:
        st.session_state[k] = v

# Auto-refresh
from streamlit_autorefresh import st_autorefresh
st_autorefresh(interval=2500, key="refresh_comb")

# Ordem f√≠sica da roleta
ROULETTE_ORDER = [
    0, 32, 15, 19, 4, 21, 2, 25, 17, 34, 6, 27, 13, 36,
    11, 30, 8, 23, 10, 5, 24, 16, 33, 1, 20, 14, 31, 9,
    22, 18, 29, 7, 28, 12, 35, 3, 26
]

def get_vizinhos(numero):
    idx = ROULETTE_ORDER.index(numero)
    return [ROULETTE_ORDER[(idx + i) % len(ROULETTE_ORDER)] for i in range(-2, 3)]

# Util: dist√¢ncia f√≠sica m√≠nima na roleta
def distancia_fisica(a, b):
    ia = ROULETTE_ORDER.index(a)
    ib = ROULETTE_ORDER.index(b)
    d = abs(ia - ib)
    return min(d, len(ROULETTE_ORDER) - d)

# Enviar telegram simples (mensagem de texto)
def enviar_telegram(msg):
    try:
        requests.post(f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage", json={"chat_id": CHAT_ID, "text": msg})
    except Exception:
        pass

def log_csv(row):
    header = ["timestamp", "evento", "numero", "tipo", "metric_score", "entrada"]
    write_header = not os.path.exists(CSV_LOG_PATH)
    with open(CSV_LOG_PATH, "a", newline="") as f:
        w = csv.writer(f)
        if write_header: w.writerow(header)
        w.writerow(row)

# ==========================
# === FUN√á√ïES COMBINAT√ìRIAS ===
# ==========================
def exponential_weights(n, halflife):
    # retorna lista de pesos para n elementos, mais recente tem maior peso (√∫ltimo index = n-1)
    # weight for age a (0 = oldest, n-1 = newest): w = 0.5^(age/halflife)
    ages = np.arange(n-1, -1, -1)  # newest age 0? invert: we want newest highest -> age = 0 for newest
    ages = np.arange(n-1, -1, -1)  # but we'll compute as age_from_end
    # Let's compute age_from_end: newest has age 0
    age_from_end = np.arange(n)[::-1]
    weights = 0.5 ** (age_from_end / halflife)
    return weights / weights.sum()

def build_transition_counts(hist):
    # Retorna dict: trans[a][b] = count de a->b
    trans = defaultdict(lambda: defaultdict(int))
    for i in range(len(hist)-1):
        a = hist[i]
        b = hist[i+1]
        trans[a][b] += 1
    return trans

def gerar_scores(hist):
    # hist: lista de ints (0-36)
    if len(hist) == 0:
        return {n: 1.0 for n in range(37)}  # sem dados, scores iguais

    # Decide janela: se usuario optou por usar todo historico, usa tudo; senao usa RECENT_WINDOW
    if USE_RECENT_ONLY:
        janela = list(hist)
    else:
        janela = list(hist[-int(RECENT_WINDOW):])

    n = len(janela)
    weights = exponential_weights(n, DECAY_HALFLIFE)  # aligned with janela oldest->newest mapping
    # frequencies ponderadas
    freq = defaultdict(float)
    for i, num in enumerate(janela):
        freq[num] += weights[i]

    # normalize frequency scores to [0,1]
    maxf = max(freq.values()) if freq else 1.0
    freq_score = {n: (freq.get(n,0.0) / maxf) for n in range(37)}

    # transitions (para condicional P(n | last))
    trans = build_transition_counts(janela)
    last = janela[-1]
    # conditional probabilities from last
    cond = {}
    denom = sum(trans[last].values()) if last in trans else 0
    if denom > 0:
        for n in range(37):
            cond[n] = trans[last].get(n, 0) / denom
    else:
        # sem transi√ß√£o conhecida, usa frequ√™ncia normalizada
        cond = {n: freq_score.get(n,0.0) for n in range(37)}

    # B√¥nus vizinhan√ßa: n√∫meros na vizinhan√ßa f√≠sica do √∫ltimo n√∫mero ganham pequeno b√¥nus
    vizinhos_last = set(get_vizinhos(last))

    # Combina para gerar score final
    scores = {}
    for n in range(37):
        s_freq = freq_score.get(n, 0.0)
        s_cond = cond.get(n, 0.0)
        bonus_viz = 0.12 if n in vizinhos_last else 0.0
        # combina√ß√£o linear (pesos ajust√°veis)
        score = 0.6 * s_freq + 0.35 * s_cond + bonus_viz
        scores[n] = float(score)

    # normalize scores into [0,1]
    arr = np.array(list(scores.values()))
    if arr.max() > arr.min():
        arrn = (arr - arr.min()) / (arr.max() - arr.min())
    else:
        arrn = arr
    for i, n in enumerate(scores.keys()):
        scores[n] = float(arrn[i])

    return scores

def selecionar_combina√ß√£o(scores, k=9, pool_top=CANDIDATE_POOL, penalty_prox=PENALTY_PROXIMITY):
    # Seleciona uma combina√ß√£o de k n√∫meros distintos a partir dos scores fornecidos
    # 1) escolhe top pool_top candidatos por score
    candidates = sorted(scores.keys(), key=lambda x: scores[x], reverse=True)[:pool_top]
    chosen = []
    chosen_set = set()

    # sele√ß√£o gulosa com penalidade por proximidade f√≠sica (para diversificar)
    for _ in range(min(k, len(candidates))):
        best = None
        best_val = -1e9
        for c in candidates:
            if c in chosen_set:
                continue
            base = scores[c]
            # penalidade por proximidade com os j√° escolhidos
            if chosen:
                prox_pen = 0.0
                for ch in chosen:
                    d = distancia_fisica(c, ch)
                    # closer -> maior penalidade (usamos inverso da dist√¢ncia)
                    prox_pen += (1.0 / (1 + d))
                prox_pen = prox_pen / len(chosen)
                val = base - penalty_prox * prox_pen
            else:
                val = base
            if val > best_val:
                best_val = val
                best = c
        if best is None:
            break
        chosen.append(best)
        chosen_set.add(best)

    # se faltou por algum motivo, preenche com pr√≥ximos melhores sem penalidade
    if len(chosen) < k:
        for c in candidates:
            if c not in chosen_set:
                chosen.append(c); chosen_set.add(c)
            if len(chosen) >= k:
                break

    # garantia de tamanho k: complementa por n√∫meros que nunca sa√≠ram (se necess√°rio)
    if len(chosen) < k:
        for n in range(37):
            if n not in chosen_set:
                chosen.append(n); chosen_set.add(n)
            if len(chosen) >= k:
                break

    # ordena por score decrescente para consist√™ncia
    chosen = sorted(chosen, key=lambda x: scores.get(x,0.0), reverse=True)
    return chosen

def gerar_combinacao_9_numeros(hist):
    scores = gerar_scores(hist)
    comb = selecionar_combina√ß√£o(scores, k=9)
    # m√©tricas: freq m√©dia ponderada dos 9 e soma dos scores normalizada
    media_scores = float(np.mean([scores.get(n,0.0) for n in comb]))
    soma_scores = float(sum([scores.get(n,0.0) for n in comb]))
    # estimativa simples de "probabilidade combinada" (heur√≠stica)
    estimativa = float(soma_scores / (sum(scores.values()) if sum(scores.values())>0 else 1.0))
    return {
        "comb": comb,
        "media_scores": media_scores,
        "soma_scores": soma_scores,
        "estimativa": estimativa,
        "scores_detail": {n: scores.get(n,0.0) for n in comb}
    }

# ==========================
# === CAPTURA DA API ===
# ==========================
try:
    r = requests.get(API_URL, timeout=5)
    if r.status_code == 200:
        d = r.json()
        numero = int(d["data"]["result"]["outcome"]["number"])
        ts = d["data"]["settledAt"]
        if ts != st.session_state.ultimo_timestamp:
            st.session_state.historico.append(numero)
            st.session_state.ultimo_timestamp = ts
            joblib.dump(list(st.session_state.historico), HISTORICO_PATH)
            st.success(f"üéØ Novo n√∫mero: {numero}")
except Exception:
    pass

# ==========================
# === GERA√á√ÉO DA PREVIS√ÉO (a cada novo n√∫mero) ===
# ==========================
hist = list(st.session_state.historico)
if hist:
    previsao = gerar_combinacao_9_numeros(hist)
    entrada_final = previsao["comb"]
    # Chave para evitar alertas duplicados id√™nticos
    chave = ",".join(map(str, entrada_final))
    if chave not in st.session_state.alertas_enviados:
        st.session_state.alertas_enviados.add(chave)
        # Mensagem compacta para Telegram (combina√ß√£o + m√©tricas)
        msg = (f"üéØ PREVIS√ÉO 9 N√öMEROS\n"
               f"{', '.join(map(str, entrada_final))}\n"
               f"‚≠ê M√©dia scores: {previsao['media_scores']:.3f} | Estimativa: {previsao['estimativa']:.4f}")
        enviar_telegram(msg)
        st.session_state.nova_entrada = True
        st.session_state.tempo_alerta = time.time()
        st.session_state.total_alertas += 1
        # Guarda entrada atual para feedback (o index_feedback aponta para o √≠ndice do pr√≥ximo n√∫mero)
        st.session_state.entrada_atual = {
            "entrada": entrada_final,
            "scores": previsao["scores_detail"],
            "index_feedback": len(hist)
        }
        log_csv([time.time(), "ALERTA_COMBINATORIA", None, None, round(previsao["soma_scores"],4), ",".join(map(str,entrada_final))])
        st.session_state.historico_scores.append(previsao["media_scores"])

# ==========================
# === FEEDBACK (confere apenas o pr√≥ximo n√∫mero) ===
# ==========================
if st.session_state.entrada_atual:
    ent = st.session_state.entrada_atual["entrada"]
    idx_fb = st.session_state.entrada_atual["index_feedback"]
    if len(st.session_state.historico) > idx_fb:
        numero_sorteado = st.session_state.historico[idx_fb]
        green = numero_sorteado in ent
        st.session_state.feedbacks_processados.add(f"{numero_sorteado}-{tuple(sorted(ent))}")
        if green:
            st.session_state.greens += 1
        else:
            st.session_state.reds += 1
        enviar_telegram(f"{'‚úÖ GREEN' if green else '‚ùå RED'} ‚Ä¢ Saiu {numero_sorteado}")
        st.session_state.entrada_atual = None

# ==========================
# === M√âTRICAS & GR√ÅFICOS ===
# ==========================
col1,col2,col3,col4 = st.columns(4)
col1.metric("‚úÖ GREENS", st.session_state.greens)
col2.metric("‚ùå REDS", st.session_state.reds)
tot = st.session_state.greens + st.session_state.reds
col3.metric("üéØ Taxa de Acerto", f"{(st.session_state.greens/tot*100 if tot>0 else 0):.1f}%")
col4.metric("üîÅ Total Alertas", st.session_state.total_alertas)

# √öltimos n√∫meros
st.subheader("üìä √öltimos n√∫meros")
st.write(list(st.session_state.historico)[-14:])

# Entrada atual (se existir)
if st.session_state.entrada_atual:
    st.subheader("üì• Entrada Atual (ordenada)")
    st.write(st.session_state.entrada_atual)

# Hist√≥rico de scores (visual)
if st.session_state.historico_scores:
    st.subheader("üìà M√©dia de Scores (√∫ltimas previs√µes)")
    fig, ax = plt.subplots(figsize=(8,2.5))
    ax.plot(list(st.session_state.historico_scores), marker='o')
    ax.set_title("Evolu√ß√£o da m√©dia de scores")
    ax.grid(True)
    st.pyplot(fig)
